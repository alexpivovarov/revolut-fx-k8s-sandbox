# --- Deployment runs pods ---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}            # release name becomes deployment name
spec:
  replicas: {{ .Values.replicaCount }} # how many pod copies
  selector:
    matchLabels:
      app: {{ .Release.Name }}         # must match pod template labels
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}       # label so Service/selector can find pods
    spec:
      containers:
        - name: {{ .Chart.Name }}      # container name (usually chart name)
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"  # image + tag from values.yaml
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: 8080      # app listens on 8080
          readinessProbe:              # when true → pod can receive traffic
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
          livenessProbe:               # when false → pod restarts
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 15
            periodSeconds: 20
          resources:
{{ toYaml .Values.resources | indent 12 }}   # CPU/mem requests/limits from values.yaml
          env:
{{- range .Values.env }}
            - name: "{{ .name }}"      # inject simple env vars from values.yaml
              value: "{{ .value }}"
{{- end }}

---
# --- Service gives a stable virtual IP/DNS for the pods ---
apiVersion: v1
kind: Service
metadata:
  name: {{ .Release.Name }}            # service name = release name
spec:
  type: {{ .Values.service.type }}     # ClusterIP/NodePort/LoadBalancer
  selector:
    app: {{ .Release.Name }}           # routes to pods with this label
  ports:
    - name: http
      port: {{ .Values.service.port }} # service port clients use
      targetPort: 8080                 # container port in the pod

